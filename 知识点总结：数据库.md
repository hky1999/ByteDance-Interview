### 数据库相关：

ACID

不考虑隔离性：脏读、不可重复读、幻读

四种隔离级别：

- 读未提交：并发最高，一致性最差
- 读已提交：解决脏读
- 可重复读：解决脏读、不可重复读
- 串行化：解决脏读、不可重复读、幻读

### 索引失效与优化

 1.全值匹配
 2.最佳左前缀法则
 3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描
 4.存储引擎不能使用索引中范围条件右边的列
 5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一直）），减少select *
 6.mysql在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描
 7.is null， is not null也无法使用索引
 8.like以通配符开头（‘%abc...’）mysql索引失效会变成全表扫描的操作
 9.字符串不加单引号索引失效
 10.少用or，用它来连接时索引会失效

### 分布式系统

CAP

- Consistency 一致性，
- Availability 可用性
- Partition tolerance 分区容错 无法避免，总是成立

一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。

### Redis：

Redis持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。

Redis 提供了两种持久化方式:RDB（默认） 和AOF 

- RDB Redis DataBase：rdbSave 、rdbLoad **快照**

- AOF Append-only file： flushAppendOnlyFile  **文本日志**

  aof写入保存：
  WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件
  SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。

### redis 高并发

​	redis之所以能解决高并发的原因是它可以直接访问内存，而以往我们用的是数据库(硬盘),提高了访问效率,解决了数据库服务器压力。

**redis通讯协议(RESP )**:RESP 是redis客户端和服务端之前使用的一种通讯协议；特点：实现简单、快速解析、可读性好

单机版、主从复制、哨兵、集群proxy型、集群直连型

#### 缓存穿透  ：恶意使用不存在的key寻找value（缓存中保存空对象，过滤）

#### 缓存击穿：某个热点数据失效，大量请求穿透到数据源（互斥锁，随机退避）

#### 缓存雪崩：缓存失效，所有的额请求都穿透到DB（快速失败熔断，主从模式核集群模式尽量保证缓存的高可用）

### 布隆过滤器

​	直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。

算法：

​	首先需要k个hash函数，每个函数可以把key散列成为1个整数
​	初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
​	某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
​	判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

优点：不需要存储key，节省空间

缺点：
	算法判断key在集合中时，有一定的概率key其实不在集合中
	无法删除

### 外部排序

​	外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序 整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排 序的子文件进行多路归并排序。

### 归并排序

### 数据库连接池

​	数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

### 分布式生成数据

#### 分布式ID的生成特性

在分析之前，我们先明确一下业务ID的生成特性，在此特性的基础上，我们能够对下面的这几种生成方式有更加深刻的认识和感悟。

- **全局唯一**，这是基本要求，不能出现重复。
- **数字类型，趋势递增**，后面的ID必须比前面的大，这是从MySQL存储引擎来考虑的，需要保证写入数据的性能。
- **长度短**，能够提高查询效率，这也是从MySQL数据库规范出发的，尤其是ID作为主键时。
- **信息安全**，如果ID连续生成，势必会泄露业务信息，甚至可能被猜出，所以需要无规则不规则。
- **高可用低延时**，ID生成快，能够扛住高并发，延时足够低不至于成为业务瓶颈。

#### 分布式ID的几种生成办法

下面介绍几种我积累的分布式ID生成办法，网络上都能够找得到，我通过学习积累并后期整理加上自己的感悟分享于此。虽然平时可能因为项目规模小而用不着，但是这种提出方案的思想还是很值得学习的，尤其是像美团的Leaf方案，我感觉特别的酷。

目录：

> - **基于UUID**  全球唯一
> - **基于数据库主键自增**
> - **基于数据库多实例主键自增** 设置不同step
> - **基于类Snowflake算法** 时间戳
> - **基于Redis生成办法** INCR
> - **基于美团的Leaf方案（ID段、双Buffer、动态调整Step）** 缓存